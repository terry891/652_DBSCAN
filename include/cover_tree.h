/*
 * Copyright (c) 2017 Manzil Zaheer All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

# ifndef _COVER_TREE_H
# define _COVER_TREE_H

//#define DEBUG

#include <atomic>
#include <fstream>
#include <iostream>
#include <stack>
#include <map>
#include <vector>
#include <shared_mutex>

#include "dataset.h"
#include "utils.h"

#ifdef __clang__
#define SHARED_MUTEX_TYPE shared_mutex
#else
#define SHARED_MUTEX_TYPE shared_timed_mutex
#endif

#include <Eigen/Core>
typedef Eigen::VectorXd pointType;
//typedef pointType::Scalar dtype;

template <typename T>
class CoverTree
{
/************************* Internal Functions ***********************************************/
public:
    /*** Base to use for the calculations ***/
    static constexpr double base = 1.3;
    static constexpr int SIZE=2048;
    //static constexpr std::array<double,2048> compute_pow_table(){
    //  std::array<double,2048> powdict{};
    //  powdict[0] = 2.098975e-117;
    //  for (int i = 1; i<2048; ++i)
    //      powdict[i] = 1.3* powdict[i-1];
    //  return powdict;
    //}
    static constexpr std::array<double,2048> powdict ={4.4057e-234,5.7274e-234,7.44563e-234,9.67931e-234,1.25831e-233,1.6358e-233,2.12655e-233,2.76451e-233,3.59386e-233,4.67202e-233,6.07363e-233,7.89571e-233,1.02644e-232,1.33438e-232,1.73469e-232,2.25509e-232,2.93162e-232,3.81111e-232,4.95444e-232,6.44078e-232,8.37301e-232,1.08849e-231,1.41504e-231,1.83955e-231,2.39141e-231,3.10884e-231,4.04149e-231,5.25394e-231,6.83012e-231,8.87916e-231,1.15429e-230,1.50058e-230,1.95075e-230,2.53598e-230,3.29677e-230,4.2858e-230,5.57154e-230,7.243e-230,9.4159e-230,1.22407e-229,1.59129e-229,2.06867e-229,2.68928e-229,3.49606e-229,4.54488e-229,5.90834e-229,7.68084e-229,9.98509e-229,1.29806e-228,1.68748e-228,2.19372e-228,2.85184e-228,3.70739e-228,4.81961e-228,6.2655e-228,8.14515e-228,1.05887e-227,1.37653e-227,1.78949e-227,2.32634e-227,3.02424e-227,3.93151e-227,5.11096e-227,6.64425e-227,8.63752e-227,1.12288e-226,1.45974e-226,1.89766e-226,2.46696e-226,3.20705e-226,4.16917e-226,5.41992e-226,7.04589e-226,9.15966e-226,1.19076e-225,1.54798e-225,2.01238e-225,2.61609e-225,3.40092e-225,4.42119e-225,5.74755e-225,7.47181e-225,9.71336e-225,1.26274e-224,1.64156e-224,2.13402e-224,2.77423e-224,3.6065e-224,4.68845e-224,6.09499e-224,7.92348e-224,1.03005e-223,1.33907e-223,1.74079e-223,2.26303e-223,2.94193e-223,3.82451e-223,4.97187e-223,6.46343e-223,8.40246e-223,1.09232e-222,1.42002e-222,1.84602e-222,2.39983e-222,3.11977e-222,4.05571e-222,5.27242e-222,6.85414e-222,8.91039e-222,1.15835e-221,1.50586e-221,1.95761e-221,2.5449e-221,3.30836e-221,4.30087e-221,5.59114e-221,7.26848e-221,9.44902e-221,1.22837e-220,1.59688e-220,2.07595e-220,2.69873e-220,3.50835e-220,4.56086e-220,5.92912e-220,7.70785e-220,1.00202e-219,1.30263e-219,1.69342e-219,2.20144e-219,2.86187e-219,3.72043e-219,4.83656e-219,6.28753e-219,8.17379e-219,1.06259e-218,1.38137e-218,1.79578e-218,2.33452e-218,3.03487e-218,3.94533e-218,5.12893e-218,6.66761e-218,8.6679e-218,1.12683e-217,1.46487e-217,1.90434e-217,2.47564e-217,3.21833e-217,4.18383e-217,5.43898e-217,7.07067e-217,9.19187e-217,1.19494e-216,1.55343e-216,2.01945e-216,2.62529e-216,3.41288e-216,4.43674e-216,5.76776e-216,7.49809e-216,9.74752e-216,1.26718e-215,1.64733e-215,2.14153e-215,2.78399e-215,3.61919e-215,4.70494e-215,6.11643e-215,7.95135e-215,1.03368e-214,1.34378e-214,1.74691e-214,2.27099e-214,2.95228e-214,3.83797e-214,4.98936e-214,6.48616e-214,8.43201e-214,1.09616e-213,1.42501e-213,1.85251e-213,2.40827e-213,3.13075e-213,4.06997e-213,5.29096e-213,6.87825e-213,8.94173e-213,1.16242e-212,1.51115e-212,1.9645e-212,2.55385e-212,3.32e-212,4.316e-212,5.6108e-212,7.29404e-212,9.48225e-212,1.23269e-211,1.6025e-211,2.08325e-211,2.70823e-211,3.52069e-211,4.5769e-211,5.94997e-211,7.73496e-211,1.00555e-210,1.30721e-210,1.69937e-210,2.20918e-210,2.87194e-210,3.73352e-210,4.85358e-210,6.30965e-210,8.20254e-210,1.06633e-209,1.38623e-209,1.8021e-209,2.34273e-209,3.04555e-209,3.95921e-209,5.14697e-209,6.69107e-209,8.69839e-209,1.13079e-208,1.47003e-208,1.91104e-208,2.48435e-208,3.22965e-208,4.19854e-208,5.45811e-208,7.09554e-208,9.2242e-208,1.19915e-207,1.55889e-207,2.02656e-207,2.63452e-207,3.42488e-207,4.45235e-207,5.78805e-207,7.52447e-207,9.78181e-207,1.27163e-206,1.65313e-206,2.14906e-206,2.79378e-206,3.63192e-206,4.72149e-206,6.13794e-206,7.97932e-206,1.03731e-205,1.3485e-205,1.75306e-205,2.27897e-205,2.96267e-205,3.85147e-205,5.0069e-205,6.50898e-205,8.46167e-205,1.10002e-204,1.43002e-204,1.85903e-204,2.41674e-204,3.14176e-204,4.08429e-204,5.30957e-204,6.90244e-204,8.97318e-204,1.16651e-203,1.51647e-203,1.97141e-203,2.56283e-203,3.33168e-203,4.33118e-203,5.63053e-203,7.3197e-203,9.5156e-203,1.23703e-202,1.60814e-202,2.09058e-202,2.71775e-202,3.53308e-202,4.593e-202,5.9709e-202,7.76217e-202,1.00908e-201,1.31181e-201,1.70535e-201,2.21695e-201,2.88204e-201,3.74665e-201,4.87065e-201,6.33184e-201,8.23139e-201,1.07008e-200,1.39111e-200,1.80844e-200,2.35097e-200,3.05626e-200,3.97314e-200,5.16508e-200,6.7146e-200,8.72898e-200,1.13477e-199,1.4752e-199,1.91776e-199,2.49308e-199,3.24101e-199,4.21331e-199,5.47731e-199,7.1205e-199,9.25665e-199,1.20336e-198,1.56437e-198,2.03369e-198,2.64379e-198,3.43693e-198,4.46801e-198,5.80841e-198,7.55093e-198,9.81621e-198,1.27611e-197,1.65894e-197,2.15662e-197,2.80361e-197,3.64469e-197,4.7381e-197,6.15953e-197,8.00738e-197,1.04096e-196,1.35325e-196,1.75922e-196,2.28699e-196,2.97309e-196,3.86501e-196,5.02451e-196,6.53187e-196,8.49143e-196,1.10389e-195,1.43505e-195,1.86557e-195,2.42524e-195,3.15281e-195,4.09865e-195,5.32825e-195,6.92672e-195,9.00474e-195,1.17062e-194,1.5218e-194,1.97834e-194,2.57184e-194,3.3434e-194,4.34641e-194,5.65034e-194,7.34544e-194,9.54907e-194,1.24138e-193,1.61379e-193,2.09793e-193,2.72731e-193,3.5455e-193,4.60915e-193,5.9919e-193,7.78947e-193,1.01263e-192,1.31642e-192,1.71135e-192,2.22475e-192,2.89218e-192,3.75983e-192,4.88778e-192,6.35411e-192,8.26034e-192,1.07384e-191,1.396e-191,1.8148e-191,2.35924e-191,3.06701e-191,3.98711e-191,5.18324e-191,6.73822e-191,8.75968e-191,1.13876e-190,1.48039e-190,1.9245e-190,2.50185e-190,3.25241e-190,4.22813e-190,5.49657e-190,7.14554e-190,9.2892e-190,1.2076e-189,1.56988e-189,2.04084e-189,2.65309e-189,3.44902e-189,4.48372e-189,5.82884e-189,7.57749e-189,9.85074e-189,1.2806e-188,1.66477e-188,2.16421e-188,2.81347e-188,3.65751e-188,4.75476e-188,6.18119e-188,8.03555e-188,1.04462e-187,1.35801e-187,1.76541e-187,2.29503e-187,2.98354e-187,3.87861e-187,5.04219e-187,6.55484e-187,8.5213e-187,1.10777e-186,1.4401e-186,1.87213e-186,2.43377e-186,3.1639e-186,4.11307e-186,5.34699e-186,6.95108e-186,9.03641e-186,1.17473e-185,1.52715e-185,1.9853e-185,2.58089e-185,3.35516e-185,4.3617e-185,5.67021e-185,7.37128e-185,9.58266e-185,1.24575e-184,1.61947e-184,2.10531e-184,2.7369e-184,3.55797e-184,4.62537e-184,6.01298e-184,7.81687e-184,1.01619e-183,1.32105e-183,1.71737e-183,2.23258e-183,2.90235e-183,3.77305e-183,4.90497e-183,6.37646e-183,8.2894e-183,1.07762e-182,1.40091e-182,1.82118e-182,2.36754e-182,3.0778e-182,4.00113e-182,5.20147e-182,6.76192e-182,8.79049e-182,1.14276e-181,1.48559e-181,1.93127e-181,2.51065e-181,3.26385e-181,4.243e-181,5.5159e-181,7.17067e-181,9.32188e-181,1.21184e-180,1.5754e-180,2.04802e-180,2.66242e-180,3.46115e-180,4.49949e-180,5.84934e-180,7.60414e-180,9.88538e-180,1.2851e-179,1.67063e-179,2.17182e-179,2.82336e-179,3.67037e-179,4.77149e-179,6.20293e-179,8.06381e-179,1.0483e-178,1.36278e-178,1.77162e-178,2.30311e-178,2.99404e-178,3.89225e-178,5.05992e-178,6.5779e-178,8.55127e-178,1.11166e-177,1.44516e-177,1.87871e-177,2.44233e-177,3.17503e-177,4.12753e-177,5.36579e-177,6.97553e-177,9.06819e-177,1.17886e-176,1.53252e-176,1.99228e-176,2.58997e-176,3.36696e-176,4.37704e-176,5.69016e-176,7.3972e-176,9.61636e-176,1.25013e-175,1.62517e-175,2.11271e-175,2.74653e-175,3.57049e-175,4.64163e-175,6.03413e-175,7.84436e-175,1.01977e-174,1.3257e-174,1.72341e-174,2.24043e-174,2.91256e-174,3.78632e-174,4.92222e-174,6.39889e-174,8.31855e-174,1.08141e-173,1.40584e-173,1.82759e-173,2.37586e-173,3.08862e-173,4.01521e-173,5.21977e-173,6.7857e-173,8.82141e-173,1.14678e-172,1.49082e-172,1.93806e-172,2.51948e-172,3.27533e-172,4.25793e-172,5.5353e-172,7.1959e-172,9.35466e-172,1.21611e-171,1.58094e-171,2.05522e-171,2.67179e-171,3.47332e-171,4.51532e-171,5.86991e-171,7.63089e-171,9.92015e-171,1.28962e-170,1.67651e-170,2.17946e-170,2.83329e-170,3.68328e-170,4.78827e-170,6.22475e-170,8.09217e-170,1.05198e-169,1.36758e-169,1.77785e-169,2.31121e-169,3.00457e-169,3.90594e-169,5.07772e-169,6.60103e-169,8.58134e-169,1.11557e-168,1.45025e-168,1.88532e-168,2.45092e-168,3.18619e-168,4.14205e-168,5.38467e-168,7.00007e-168,9.10009e-168,1.18301e-167,1.53791e-167,1.99929e-167,2.59908e-167,3.3788e-167,4.39244e-167,5.71017e-167,7.42322e-167,9.65019e-167,1.25452e-166,1.63088e-166,2.12015e-166,2.75619e-166,3.58305e-166,4.65796e-166,6.05535e-166,7.87195e-166,1.02335e-165,1.33036e-165,1.72947e-165,2.24831e-165,2.9228e-165,3.79964e-165,4.93953e-165,6.42139e-165,8.34781e-165,1.08522e-164,1.41078e-164,1.83401e-164,2.38422e-164,3.09948e-164,4.02933e-164,5.23813e-164,6.80957e-164,8.85244e-164,1.15082e-163,1.49606e-163,1.94488e-163,2.52834e-163,3.28685e-163,4.2729e-163,5.55477e-163,7.2212e-163,9.38757e-163,1.22038e-162,1.5865e-162,2.06245e-162,2.68118e-162,3.48554e-162,4.5312e-162,5.89056e-162,7.65773e-162,9.95504e-162,1.29416e-161,1.6824e-161,2.18712e-161,2.84326e-161,3.69624e-161,4.80511e-161,6.24664e-161,8.12064e-161,1.05568e-160,1.37239e-160,1.7841e-160,2.31933e-160,3.01514e-160,3.91968e-160,5.09558e-160,6.62425e-160,8.61153e-160,1.1195e-159,1.45535e-159,1.89195e-159,2.45954e-159,3.1974e-159,4.15662e-159,5.40361e-159,7.02469e-159,9.13209e-159,1.18717e-158,1.54332e-158,2.00632e-158,2.60822e-158,3.39068e-158,4.40789e-158,5.73025e-158,7.44933e-158,9.68413e-158,1.25894e-157,1.63662e-157,2.1276e-157,2.76588e-157,3.59565e-157,4.67434e-157,6.07665e-157,7.89964e-157,1.02695e-156,1.33504e-156,1.73555e-156,2.25622e-156,2.93308e-156,3.81301e-156,4.95691e-156,6.44398e-156,8.37717e-156,1.08903e-155,1.41574e-155,1.84047e-155,2.3926e-155,3.11039e-155,4.0435e-155,5.25655e-155,6.83352e-155,8.88357e-155,1.15486e-154,1.50132e-154,1.95172e-154,2.53724e-154,3.29841e-154,4.28793e-154,5.57431e-154,7.2466e-154,9.42058e-154,1.22468e-153,1.59208e-153,2.0697e-153,2.69061e-153,3.4978e-153,4.54714e-153,5.91128e-153,7.68466e-153,9.99006e-153,1.29871e-152,1.68832e-152,2.19482e-152,2.85326e-152,3.70924e-152,4.82201e-152,6.26861e-152,8.1492e-152,1.0594e-151,1.37721e-151,1.79038e-151,2.32749e-151,3.02574e-151,3.93346e-151,5.1135e-151,6.64755e-151,8.64182e-151,1.12344e-150,1.46047e-150,1.89861e-150,2.46819e-150,3.20865e-150,4.17124e-150,5.42261e-150,7.04939e-150,9.16421e-150,1.19135e-149,1.54875e-149,2.01338e-149,2.61739e-149,3.40261e-149,4.42339e-149,5.75041e-149,7.47553e-149,9.71819e-149,1.26336e-148,1.64237e-148,2.13509e-148,2.77561e-148,3.6083e-148,4.69078e-148,6.09802e-148,7.92743e-148,1.03057e-147,1.33973e-147,1.74166e-147,2.26415e-147,2.9434e-147,3.82642e-147,4.97434e-147,6.46664e-147,8.40664e-147,1.09286e-146,1.42072e-146,1.84694e-146,2.40102e-146,3.12133e-146,4.05772e-146,5.27504e-146,6.85755e-146,8.91482e-146,1.15893e-145,1.5066e-145,1.95859e-145,2.54616e-145,3.31001e-145,4.30301e-145,5.59392e-145,7.27209e-145,9.45372e-145,1.22898e-144,1.59768e-144,2.07698e-144,2.70008e-144,3.5101e-144,4.56313e-144,5.93207e-144,7.71169e-144,1.00252e-143,1.30328e-143,1.69426e-143,2.20254e-143,2.8633e-143,3.72228e-143,4.83897e-143,6.29066e-143,8.17786e-143,1.06312e-142,1.38206e-142,1.79668e-142,2.33568e-142,3.03638e-142,3.9473e-142,5.13149e-142,6.67093e-142,8.67221e-142,1.12739e-141,1.4656e-141,1.90528e-141,2.47687e-141,3.21993e-141,4.18591e-141,5.44168e-141,7.07419e-141,9.19645e-141,1.19554e-140,1.5542e-140,2.02046e-140,2.6266e-140,3.41458e-140,4.43895e-140,5.77063e-140,7.50182e-140,9.75237e-140,1.26781e-139,1.64815e-139,2.1426e-139,2.78537e-139,3.62099e-139,4.70728e-139,6.11947e-139,7.95531e-139,1.03419e-138,1.34445e-138,1.74778e-138,2.27212e-138,2.95375e-138,3.83988e-138,4.99184e-138,6.48939e-138,8.43621e-138,1.09671e-137,1.42572e-137,1.85343e-137,2.40946e-137,3.1323e-137,4.072e-137,5.29359e-137,6.88167e-137,8.94617e-137,1.163e-136,1.5119e-136,1.96547e-136,2.55512e-136,3.32165e-136,4.31815e-136,5.61359e-136,7.29767e-136,9.48697e-136,1.23331e-135,1.6033e-135,2.08429e-135,2.70957e-135,3.52245e-135,4.57918e-135,5.95293e-135,7.73881e-135,1.00605e-134,1.30786e-134,1.70022e-134,2.21028e-134,2.87337e-134,3.73538e-134,4.85599e-134,6.31279e-134,8.20662e-134,1.06686e-133,1.38692e-133,1.803e-133,2.34389e-133,3.04706e-133,3.96118e-133,5.14953e-133,6.69439e-133,8.70271e-133,1.13135e-132,1.47076e-132,1.91199e-132,2.48558e-132,3.23126e-132,4.20063e-132,5.46082e-132,7.09907e-132,9.22879e-132,1.19974e-131,1.55967e-131,2.02757e-131,2.63584e-131,3.42659e-131,4.45456e-131,5.79093e-131,7.52821e-131,9.78667e-131,1.27227e-130,1.65395e-130,2.15013e-130,2.79517e-130,3.63372e-130,4.72384e-130,6.14099e-130,7.98329e-130,1.03783e-129,1.34918e-129,1.75393e-129,2.28011e-129,2.96414e-129,3.85338e-129,5.0094e-129,6.51221e-129,8.46588e-129,1.10056e-128,1.43073e-128,1.85995e-128,2.41794e-128,3.14332e-128,4.08632e-128,5.31221e-128,6.90588e-128,8.97764e-128,1.16709e-127,1.51722e-127,1.97239e-127,2.5641e-127,3.33333e-127,4.33334e-127,5.63334e-127,7.32334e-127,9.52034e-127,1.23764e-126,1.60894e-126,2.09162e-126,2.7191e-126,3.53483e-126,4.59529e-126,5.97387e-126,7.76603e-126,1.00958e-125,1.31246e-125,1.7062e-125,2.21806e-125,2.88347e-125,3.74852e-125,4.87307e-125,6.33499e-125,8.23549e-125,1.07061e-124,1.3918e-124,1.80934e-124,2.35214e-124,3.05778e-124,3.97511e-124,5.16765e-124,6.71794e-124,8.73332e-124,1.13533e-123,1.47593e-123,1.91871e-123,2.49432e-123,3.24262e-123,4.21541e-123,5.48003e-123,7.12404e-123,9.26125e-123,1.20396e-122,1.56515e-122,2.0347e-122,2.64511e-122,3.43864e-122,4.47023e-122,5.8113e-122,7.55469e-122,9.82109e-122,1.27674e-121,1.65976e-121,2.15769e-121,2.805e-121,3.6465e-121,4.74045e-121,6.16259e-121,8.01137e-121,1.04148e-120,1.35392e-120,1.7601e-120,2.28813e-120,2.97456e-120,3.86693e-120,5.02701e-120,6.53512e-120,8.49565e-120,1.10444e-119,1.43577e-119,1.8665e-119,2.42644e-119,3.15438e-119,4.10069e-119,5.3309e-119,6.93017e-119,9.00922e-119,1.1712e-118,1.52256e-118,1.97932e-118,2.57312e-118,3.34506e-118,4.34858e-118,5.65315e-118,7.34909e-118,9.55382e-118,1.242e-117,1.6146e-117,2.09897e-117,2.72867e-117,3.54727e-117,4.61145e-117,5.99488e-117,7.79335e-117,1.01314e-116,1.31708e-116,1.7122e-116,2.22586e-116,2.89362e-116,3.7617e-116,4.89021e-116,6.35727e-116,8.26445e-116,1.07438e-115,1.39669e-115,1.8157e-115,2.36041e-115,3.06853e-115,3.98909e-115,5.18582e-115,6.74157e-115,8.76404e-115,1.13933e-114,1.48112e-114,1.92546e-114,2.5031e-114,3.25403e-114,4.23023e-114,5.49931e-114,7.1491e-114,9.29383e-114,1.2082e-113,1.57066e-113,2.04185e-113,2.65441e-113,3.45073e-113,4.48595e-113,5.83174e-113,7.58126e-113,9.85564e-113,1.28123e-112,1.6656e-112,2.16528e-112,2.81487e-112,3.65933e-112,4.75713e-112,6.18427e-112,8.03955e-112,1.04514e-111,1.35868e-111,1.76629e-111,2.29617e-111,2.98503e-111,3.88054e-111,5.0447e-111,6.5581e-111,8.52554e-111,1.10832e-110,1.44082e-110,1.87306e-110,2.43498e-110,3.16547e-110,4.11511e-110,5.34965e-110,6.95454e-110,9.0409e-110,1.17532e-109,1.52791e-109,1.98629e-109,2.58217e-109,3.35682e-109,4.36387e-109,5.67303e-109,7.37494e-109,9.58743e-109,1.24637e-108,1.62027e-108,2.10636e-108,2.73826e-108,3.55974e-108,4.62767e-108,6.01597e-108,7.82076e-108,1.0167e-107,1.32171e-107,1.71822e-107,2.23369e-107,2.90379e-107,3.77493e-107,4.90741e-107,6.37963e-107,8.29352e-107,1.07816e-106,1.40161e-106,1.82209e-106,2.36871e-106,3.07933e-106,4.00312e-106,5.20406e-106,6.76528e-106,8.79486e-106,1.14333e-105,1.48633e-105,1.93223e-105,2.5119e-105,3.26547e-105,4.24511e-105,5.51865e-105,7.17424e-105,9.32651e-105,1.21245e-104,1.57618e-104,2.04904e-104,2.66375e-104,3.46287e-104,4.50173e-104,5.85225e-104,7.60792e-104,9.8903e-104,1.28574e-103,1.67146e-103,2.1729e-103,2.82477e-103,3.6722e-103,4.77386e-103,6.20602e-103,8.06782e-103,1.04882e-102,1.36346e-102,1.7725e-102,2.30425e-102,2.99553e-102,3.89418e-102,5.06244e-102,6.58117e-102,8.55552e-102,1.11222e-101,1.44588e-101,1.87965e-101,2.44354e-101,3.17661e-101,4.12959e-101,5.36846e-101,6.979e-101,9.0727e-101,1.17945e-100,1.53329e-100,1.99327e-100,2.59125e-100,3.36863e-100,4.37922e-100,5.69299e-100,7.40088e-100,9.62115e-100,1.25075e-99,1.62597e-99,2.11377e-99,2.7479e-99,3.57226e-99,4.64394e-99,6.03713e-99,7.84827e-99,1.02027e-98,1.32636e-98,1.72426e-98,2.24154e-98,2.91401e-98,3.78821e-98,4.92467e-98,6.40207e-98,8.32269e-98,1.08195e-97,1.40653e-97,1.8285e-97,2.37704e-97,3.09016e-97,4.0172e-97,5.22237e-97,6.78908e-97,8.8258e-97,1.14735e-96,1.49156e-96,1.93903e-96,2.52074e-96,3.27696e-96,4.26004e-96,5.53806e-96,7.19947e-96,9.35932e-96,1.21671e-95,1.58172e-95,2.05624e-95,2.67311e-95,3.47505e-95,4.51756e-95,5.87283e-95,7.63468e-95,9.92509e-95,1.29026e-94,1.67734e-94,2.18054e-94,2.8347e-94,3.68512e-94,4.79065e-94,6.22785e-94,8.0962e-94,1.05251e-93,1.36826e-93,1.77873e-93,2.31236e-93,3.00606e-93,3.90788e-93,5.08024e-93,6.60432e-93,8.58561e-93,1.11613e-92,1.45097e-92,1.88626e-92,2.45214e-92,3.18778e-92,4.14411e-92,5.38735e-92,7.00355e-92,9.10461e-92,1.1836e-91,1.53868e-91,2.00028e-91,2.60037e-91,3.38048e-91,4.39462e-91,5.71301e-91,7.42691e-91,9.65499e-91,1.25515e-90,1.63169e-90,2.1212e-90,2.75756e-90,3.58483e-90,4.66028e-90,6.05836e-90,7.87587e-90,1.02386e-89,1.33102e-89,1.73033e-89,2.24943e-89,2.92426e-89,3.80153e-89,4.94199e-89,6.42459e-89,8.35197e-89,1.08576e-88,1.41148e-88,1.83493e-88,2.3854e-88,3.10103e-88,4.03133e-88,5.24073e-88,6.81295e-88,8.85684e-88,1.15139e-87,1.49681e-87,1.94585e-87,2.5296e-87,3.28848e-87,4.27503e-87,5.55754e-87,7.2248e-87,9.39224e-87,1.22099e-86,1.58729e-86,2.06347e-86,2.68252e-86,3.48727e-86,4.53345e-86,5.89349e-86,7.66154e-86,9.96e-86,1.2948e-85,1.68324e-85,2.18821e-85,2.84467e-85,3.69808e-85,4.8075e-85,6.24975e-85,8.12468e-85,1.05621e-84,1.37307e-84,1.78499e-84,2.32049e-84,3.01663e-84,3.92163e-84,5.09811e-84,6.62755e-84,8.61581e-84,1.12006e-83,1.45607e-83,1.89289e-83,2.46076e-83,3.19899e-83,4.15869e-83,5.40629e-83,7.02818e-83,9.13664e-83,1.18776e-82,1.54409e-82,2.00732e-82,2.60951e-82,3.39237e-82,4.41008e-82,5.7331e-82,7.45303e-82,9.68895e-82,1.25956e-81,1.63743e-81,2.12866e-81,2.76726e-81,3.59744e-81,4.67667e-81,6.07967e-81,7.90357e-81,1.02746e-80,1.3357e-80,1.73641e-80,2.25734e-80,2.93454e-80,3.8149e-80,4.95937e-80,6.44719e-80,8.38134e-80,1.08957e-79,1.41645e-79,1.84138e-79,2.39379e-79,3.11193e-79,4.04551e-79,5.25917e-79,6.83692e-79,8.88799e-79,1.15544e-78,1.50207e-78,1.95269e-78,2.5385e-78,3.30005e-78,4.29006e-78,5.57708e-78,7.25021e-78,9.42527e-78,1.22529e-77,1.59287e-77,2.07073e-77,2.69195e-77,3.49954e-77,4.5494e-77,5.91422e-77,7.68848e-77,9.99503e-77,1.29935e-76,1.68916e-76,2.19591e-76,2.85468e-76,3.71108e-76,4.82441e-76,6.27173e-76,8.15325e-76,1.05992e-75,1.3779e-75,1.79127e-75,2.32865e-75,3.02725e-75,3.93542e-75,5.11604e-75,6.65086e-75,8.64611e-75,1.12399e-74,1.46119e-74,1.89955e-74,2.46942e-74,3.21024e-74,4.17331e-74,5.42531e-74,7.0529e-74,9.16877e-74,1.19194e-73,1.54952e-73,2.01438e-73,2.61869e-73,3.4043e-73,4.42559e-73,5.75327e-73,7.47925e-73,9.72302e-73,1.26399e-72,1.64319e-72,2.13615e-72,2.77699e-72,3.61009e-72,4.69312e-72,6.10105e-72,7.93137e-72,1.03108e-71,1.3404e-71,1.74252e-71,2.26528e-71,2.94486e-71,3.82832e-71,4.97682e-71,6.46986e-71,8.41082e-71,1.09341e-70,1.42143e-70,1.84786e-70,2.40221e-70,3.12288e-70,4.05974e-70,5.27766e-70,6.86096e-70,8.91925e-70,1.1595e-69,1.50735e-69,1.95956e-69,2.54743e-69,3.31166e-69,4.30515e-69,5.5967e-69,7.27571e-69,9.45842e-69,1.22959e-68,1.59847e-68,2.07802e-68,2.70142e-68,3.51185e-68,4.5654e-68,5.93502e-68,7.71553e-68,1.00302e-67,1.30392e-67,1.6951e-67,2.20363e-67,2.86472e-67,3.72414e-67,4.84138e-67,6.29379e-67,8.18193e-67,1.06365e-66,1.38275e-66,1.79757e-66,2.33684e-66,3.03789e-66,3.94926e-66,5.13404e-66,6.67425e-66,8.67653e-66,1.12795e-65,1.46633e-65,1.90623e-65,2.4781e-65,3.22153e-65,4.18799e-65,5.44439e-65,7.07771e-65,9.20102e-65,1.19613e-64,1.55497e-64,2.02146e-64,2.6279e-64,3.41627e-64,4.44116e-64,5.7735e-64,7.50556e-64,9.75722e-64,1.26844e-63,1.64897e-63,2.14366e-63,2.78676e-63,3.62279e-63,4.70962e-63,6.12251e-63,7.95927e-63,1.0347e-62,1.34512e-62,1.74865e-62,2.27325e-62,2.95522e-62,3.84179e-62,4.99432e-62,6.49262e-62,8.4404e-62,1.09725e-61,1.42643e-61,1.85436e-61,2.41066e-61,3.13386e-61,4.07402e-61,5.29623e-61,6.8851e-61,8.95062e-61,1.16358e-60,1.51266e-60,1.96645e-60,2.55639e-60,3.3233e-60,4.3203e-60,5.61638e-60,7.3013e-60,9.49169e-60,1.23392e-59,1.6041e-59,2.08532e-59,2.71092e-59,3.5242e-59,4.58146e-59,5.95589e-59,7.74266e-59,1.00655e-58,1.30851e-58,1.70106e-58,2.21138e-58,2.8748e-58,3.73724e-58,4.85841e-58,6.31593e-58,8.21071e-58,1.06739e-57,1.38761e-57,1.80389e-57,2.34506e-57,3.04858e-57,3.96315e-57,5.1521e-57,6.69773e-57,8.70704e-57,1.13192e-56,1.47149e-56,1.91294e-56,2.48682e-56,3.23286e-56,4.20272e-56,5.46354e-56,7.1026e-56,9.23338e-56,1.20034e-55,1.56044e-55,2.02857e-55,2.63715e-55,3.42829e-55,4.45678e-55,5.79381e-55,7.53195e-55,9.79154e-55,1.2729e-54,1.65477e-54,2.1512e-54,2.79656e-54,3.63553e-54,4.72619e-54,6.14405e-54,7.98726e-54,1.03834e-53,1.34985e-53,1.7548e-53,2.28124e-53,2.96561e-53,3.8553e-53,5.01189e-53,6.51545e-53,8.47009e-53,1.10111e-52,1.43145e-52,1.86088e-52,2.41914e-52,3.14488e-52,4.08835e-52,5.31486e-52,6.90931e-52,8.98211e-52,1.16767e-51,1.51798e-51,1.97337e-51,2.56538e-51,3.33499e-51,4.33549e-51,5.63614e-51,7.32698e-51,9.52507e-51,1.23826e-50,1.60974e-50,2.09266e-50,2.72046e-50,3.53659e-50,4.59757e-50,5.97684e-50,7.7699e-50,1.01009e-49,1.31311e-49,1.70705e-49,2.21916e-49,2.88491e-49,3.75038e-49,4.87549e-49,6.33814e-49,8.23958e-49,1.07115e-48,1.39249e-48,1.81024e-48,2.35331e-48,3.0593e-48,3.97709e-48,5.17022e-48,6.72128e-48,8.73767e-48,1.1359e-47,1.47667e-47,1.91967e-47,2.49557e-47,3.24423e-47,4.21751e-47,5.48276e-47,7.12758e-47,9.26586e-47,1.20456e-46,1.56593e-46,2.03571e-46,2.64642e-46,3.44035e-46,4.47245e-46,5.81419e-46,7.55845e-46,9.82598e-46,1.27738e-45,1.66059e-45,2.15877e-45,2.8064e-45,3.64832e-45,4.74281e-45,6.16566e-45,8.01535e-45,1.042e-44,1.35459e-44,1.76097e-44,2.28926e-44,2.97604e-44,3.86886e-44,5.02952e-44,6.53837e-44,8.49988e-44,1.10498e-43,1.43648e-43,1.86742e-43,2.42765e-43,3.15595e-43,4.10273e-43,5.33355e-43,6.93361e-43,9.0137e-43,1.17178e-42,1.52331e-42,1.98031e-42,2.5744e-42,3.34672e-42,4.35074e-42,5.65596e-42,7.35275e-42,9.55858e-42,1.24261e-41,1.6154e-41,2.10002e-41,2.73002e-41,3.54903e-41,4.61374e-41,5.99786e-41,7.79722e-41,1.01364e-40,1.31773e-40,1.71305e-40,2.22697e-40,2.89505e-40,3.76357e-40,4.89264e-40,6.36043e-40,8.26857e-40,1.07491e-39,1.39739e-39,1.8166e-39,2.36158e-39,3.07006e-39,3.99108e-39,5.1884e-39,6.74492e-39,8.7684e-39,1.13989e-38,1.48186e-38,1.92642e-38,2.50434e-38,3.25565e-38,4.23234e-38,5.50204e-38,7.15265e-38,9.29845e-38,1.2088e-37,1.57144e-37,2.04287e-37,2.65573e-37,3.45245e-37,4.48818e-37,5.83464e-37,7.58503e-37,9.86054e-37,1.28187e-36,1.66643e-36,2.16636e-36,2.81627e-36,3.66115e-36,4.75949e-36,6.18734e-36,8.04354e-36,1.04566e-35,1.35936e-35,1.76717e-35,2.29732e-35,2.98651e-35,3.88247e-35,5.04721e-35,6.56137e-35,8.52978e-35,1.10887e-34,1.44153e-34,1.87399e-34,2.43619e-34,3.16705e-34,4.11716e-34,5.35231e-34,6.958e-34,9.0454e-34,1.1759e-33,1.52867e-33,1.98727e-33,2.58346e-33,3.35849e-33,4.36604e-33,5.67586e-33,7.37861e-33,9.5922e-33,1.24699e-32,1.62108e-32,2.10741e-32,2.73963e-32,3.56151e-32,4.62997e-32,6.01896e-32,7.82465e-32,1.0172e-31,1.32237e-31,1.71908e-31,2.2348e-31,2.90524e-31,3.77681e-31,4.90985e-31,6.38281e-31,8.29765e-31,1.07869e-30,1.4023e-30,1.82299e-30,2.36989e-30,3.08086e-30,4.00512e-30,5.20665e-30,6.76865e-30,8.79924e-30,1.1439e-29,1.48707e-29,1.93319e-29,2.51315e-29,3.2671e-29,4.24723e-29,5.52139e-29,7.17781e-29,9.33115e-29,1.21305e-28,1.57696e-28,2.05005e-28,2.66507e-28,3.46459e-28,4.50397e-28,5.85516e-28,7.61171e-28,9.89522e-28,1.28638e-27,1.67229e-27,2.17398e-27,2.82617e-27,3.67403e-27,4.77623e-27,6.2091e-27,8.07184e-27,1.04934e-26,1.36414e-26,1.77338e-26,2.3054e-26,2.99702e-26,3.89612e-26,5.06496e-26,6.58444e-26,8.55978e-26,1.11277e-25,1.4466e-25,1.88058e-25,2.44476e-25,3.17819e-25,4.13164e-25,5.37113e-25,6.98247e-25,9.07722e-25,1.18004e-24,1.53405e-24,1.99426e-24,2.59254e-24,3.37031e-24,4.3814e-24,5.69582e-24,7.40456e-24,9.62593e-24,1.25137e-23,1.62678e-23,2.11482e-23,2.74926e-23,3.57404e-23,4.64625e-23,6.04013e-23,7.85217e-23,1.02078e-22,1.32702e-22,1.72512e-22,2.24266e-22,2.91546e-22,3.79009e-22,4.92712e-22,6.40526e-22,8.32683e-22,1.08249e-21,1.40723e-21,1.82941e-21,2.37823e-21,3.09169e-21,4.0192e-21,5.22496e-21,6.79245e-21,8.83019e-21,1.14792e-20,1.4923e-20,1.93999e-20,2.52199e-20,3.27859e-20,4.26216e-20,5.54081e-20,7.20306e-20,9.36397e-20,1.21732e-19,1.58251e-19,2.05726e-19,2.67444e-19,3.47678e-19,4.51981e-19,5.87575e-19,7.63848e-19,9.93002e-19,1.2909e-18,1.67817e-18,2.18163e-18,2.83611e-18,3.68695e-18,4.79303e-18,6.23094e-18,8.10023e-18,1.05303e-17,1.36894e-17,1.77962e-17,2.31351e-17,3.00756e-17,3.90982e-17,5.08277e-17,6.6076e-17,8.58988e-17,1.11668e-16,1.45169e-16,1.8872e-16,2.45336e-16,3.18936e-16,4.14617e-16,5.39003e-16,7.00703e-16,9.10914e-16,1.18419e-15,1.53945e-15,2.00128e-15,2.60166e-15,3.38216e-15,4.39681e-15,5.71585e-15,7.43061e-15,9.65979e-15,1.25577e-14,1.6325e-14,2.12226e-14,2.75893e-14,3.58661e-14,4.6626e-14,6.06137e-14,7.87979e-14,1.02437e-13,1.33168e-13,1.73119e-13,2.25055e-13,2.92571e-13,3.80342e-13,4.94445e-13,6.42778e-13,8.35612e-13,1.0863e-12,1.41218e-12,1.83584e-12,2.38659e-12,3.10257e-12,4.03334e-12,5.24334e-12,6.81634e-12,8.86125e-12,1.15196e-11,1.49755e-11,1.94682e-11,2.53086e-11,3.29012e-11,4.27715e-11,5.5603e-11,7.22839e-11,9.39691e-11,1.2216e-10,1.58808e-10,2.0645e-10,2.68385e-10,3.48901e-10,4.53571e-10,5.89642e-10,7.66535e-10,9.96495e-10,1.29544e-09,1.68408e-09,2.1893e-09,2.84609e-09,3.69992e-09,4.80989e-09,6.25286e-09,8.12872e-09,1.05673e-08,1.37375e-08,1.78588e-08,2.32164e-08,3.01814e-08,3.92358e-08,5.10065e-08,6.63084e-08,8.6201e-08,1.12061e-07,1.4568e-07,1.89384e-07,2.46199e-07,3.20058e-07,4.16076e-07,5.40898e-07,7.03168e-07,9.14118e-07,1.18835e-06,1.54486e-06,2.00832e-06,2.61081e-06,3.39406e-06,4.41227e-06,5.73596e-06,7.45674e-06,9.69377e-06,1.26019e-05,1.63825e-05,2.12972e-05,2.76864e-05,3.59923e-05,4.679e-05,6.08269e-05,7.9075e-05,0.000102798,0.000133637,0.000173728,0.000225846,0.0002936,0.00038168,0.000496184,0.000645039,0.000838551,0.00109012,0.00141715,0.0018423,0.00239499,0.00311348,0.00404753,0.00526178,0.00684032,0.00889241,0.0115601,0.0150282,0.0195366,0.0253976,0.0330169,0.042922,0.0557986,0.0725382,0.0942996,0.122589,0.159366,0.207176,0.269329,0.350128,0.455166,0.591716,0.769231};

    /*** structure for each node ***/
    struct Node
    {
        pointType _p;                       // point associated with the node
        std::vector<Node*> children;        // list of children
        int level;                          // current level of the node
        double maxdistUB;                   // upper bound of distance to any of descendants
        unsigned ID;                        // unique ID of current node
        Node* parent;                       // parent of current node

        mutable std::SHARED_MUTEX_TYPE mut;// lock for current node

        /*** Node modifiers ***/
        double covdist()                    // covering distance of subtree at current node
        {
            return powdict[level + 1024];
        }
        double sepdist()                    // separating distance between nodes at current level
        {
            return powdict[level + 1023];
        }
        double dist(const pointType& pp) const  // L2 distance between current node and point pp
        {
            return (_p - pp).norm();
        }
        double dist(Node* n) const              // L2 distance between current node and node n
        {
            return (_p - n->_p).norm();
        }
        Node* setChild(const pointType& pIns, int new_id=-1)   // insert a new child of current node with point pIns
        {
            Node* temp = new Node;
            temp->_p = pIns;
            temp->level = level - 1;
            temp->maxdistUB = 0; // powdict[level + 1024];
            temp->ID = new_id;
            temp->parent = this;
            children.push_back(temp);
            return temp;
        }
        Node* setChild(Node* pIns)          // insert the subtree pIns as child of current node
        {
            if( pIns->level != level - 1)
            {
                Node* current = pIns;
                std::stack<Node*> travel;
                current->level = level-1;
                //current->maxdistUB = powdict[level + 1024];
                travel.push(current);
                while (!travel.empty())
                {
                    current = travel.top();
                    travel.pop();

                    for (const auto& child : *current)
                    {
                        child->level = current->level-1;
                        //child->maxdistUB = powdict[child->level + 1025];
                        travel.push(child);
                    }

                }
            }
            pIns->parent = this;
            children.push_back(pIns);
            return pIns;
        }

        /*** erase child ***/
        void erase(size_t pos)
        {
            children[pos] = children.back();
            children.pop_back();
        }

        void erase(typename std::vector<CoverTree<T>::Node*>::iterator pos)
        {
            *pos = children.back();
            children.pop_back();
        }

        /*** Iterator access ***/
        inline typename std::vector<CoverTree<T>::Node*>::iterator begin()
        {
            return children.begin();
        }
        inline typename std::vector<CoverTree<T>::Node*>::iterator end()
        {
            return children.end();
        }
        inline typename std::vector<CoverTree<T>::Node*>::const_iterator begin() const
        {
            return children.begin();
        }
        inline typename std::vector<CoverTree<T>::Node*>::const_iterator end() const
        {
            return children.end();
        }
    };
    // mutable std::map<int,std::atomic<unsigned>> dist_count;
    std::map<int,unsigned> level_count;

protected:
    Node* root;                         // Root of the tree
    std::atomic<int> min_scale;         // Minimum scale
    std::atomic<int> max_scale;         // Minimum scale
    //int min_scale;                    // Minimum scale
    //int max_scale;                    // Minimum scale
    int truncate_level;                 // Relative level below which the tree is truncated
    bool id_valid;
    std::vector<T> mean_data;

    std::atomic<size_t> N;            // Number of points in the cover tree
    //unsigned N;                       // Number of points in the cover tree
    unsigned D;                         // Dimension of the points

    std::SHARED_MUTEX_TYPE global_mut;  // lock for changing the root

    /*** Insert point or node at current node ***/
    bool insert(Node* current, const pointType& p){
      bool result = false;
      if (truncate_level > 0 && current->level < max_scale-truncate_level)
          return false;
  
      // acquire read lock
      current->mut.lock_shared();
  
      // Sort the children
      unsigned num_children = current->children.size();
      std::vector<int> idx(num_children);
      std::iota(std::begin(idx), std::end(idx), 0);
      std::vector<double> dists(num_children);
      for (unsigned i = 0; i < num_children; ++i)
          dists[i] = current->children[i]->dist(p);
      auto comp_x = [&dists](int a, int b) { return dists[a] < dists[b]; };
      std::sort(std::begin(idx), std::end(idx), comp_x);
  
      bool flag = true;
      for (const auto& child_idx : idx)
      {
          Node* child = current->children[child_idx];
          double dist_child = dists[child_idx];
          if (dist_child <= 0.0)
          {
              // release read lock then enter child
              current->mut.unlock_shared();
              flag = false;
              std::cout << "Duplicate entry!!!" << std::endl;
              break;
          }
          else if (dist_child <= child->covdist())
          {
              // release read lock then enter child
              if (child->maxdistUB < dist_child)
                  child->maxdistUB = dist_child;
              current->mut.unlock_shared();
              result = insert(child, p);
              flag = false;
              break;
          }
      }
  
      if (flag)
      {
          // release read lock then acquire write lock
          current->mut.unlock_shared();
          current->mut.lock();
          // check if insert is still valid, i.e. no other point was inserted else restart
          if (num_children==current->children.size())
          {
              int new_id = ++N;
              current->setChild(p, new_id);
              result = true;
              current->mut.unlock();
  
              int local_min = min_scale.load();
              while( local_min > current->level - 1){
                  min_scale.compare_exchange_weak(local_min, current->level - 1, std::memory_order_relaxed, std::memory_order_relaxed);
                  local_min = min_scale.load();
              }
          }
          else
          {
              current->mut.unlock();
              result = insert(current, p);
          }
      }
      return result;

    }
    bool insert(Node* current, Node* p){
      bool result = false;
      std::cout << "Node insert called!";
      if (truncate_level > 0 && current->level < max_scale-truncate_level)
          return false;

      // acquire read lock
      current->mut.lock_shared();

      // Sort the children
      unsigned num_children = current->children.size();
      std::vector<int> idx(num_children);
      std::iota(std::begin(idx), std::end(idx), 0);
      std::vector<double> dists(num_children);
      for (unsigned i = 0; i < num_children; ++i)
          dists[i] = current->children[i]->dist(p);
      auto comp_x = [&dists](int a, int b) { return dists[a] < dists[b]; };
      std::sort(std::begin(idx), std::end(idx), comp_x);

      bool flag = true;
      for (const auto& child_idx : idx)
      {
          Node* child = current->children[child_idx];
          double dist_child = dists[child_idx];
          if (dist_child <= 0.0)
          {
              // release read lock then enter child
              current->mut.unlock_shared();
              flag = false;
              break;
          }
          else if (dist_child <= child->covdist())
          {
              // release read lock then enter child
              current->mut.unlock_shared();
              result = insert(child, p);
              flag = false;
              break;
          }
      }

      if (flag)
      {
          // release read lock then acquire write lock
          current->mut.unlock_shared();
          current->mut.lock();
          // check if insert is still valid, i.e. no other point was inserted else restart
          if (num_children==current->children.size())
          {
              ++N;
              current->setChild(p);
              result = true;
              current->mut.unlock();

              int local_min = min_scale.load();
              while( local_min > current->level - 1){
                  min_scale.compare_exchange_weak(local_min, current->level - 1, std::memory_order_relaxed, std::memory_order_relaxed);
                  local_min = min_scale.load();
              }
          }
          else
          {
              current->mut.unlock();
              result = insert(current, p);
          }
      }
      return result;

    }


    /*** debug functions ***/
    unsigned msg_size() const{
      return 2 * sizeof(unsigned) + sizeof(pointType::Scalar)*D*N + sizeof(int)*N + sizeof(unsigned)*N;
    }
    void calc_maxdist(){                            //find true maxdist
      std::vector<CoverTree::Node*> travel;
      std::vector<CoverTree::Node*> active;
      CoverTree::Node* current = root;

      root->maxdistUB = 0.0;
      travel.push_back(root);
      while (!travel.empty())
      {
          current = travel.back();
          if (current->maxdistUB <= 0) {
              while (current->children.size()>0)
              {
                  active.push_back(current);
                  // push the children
                  for (int i = current->children.size() - 1; i >= 0; --i)
                  {
                      current->children[i]->maxdistUB = 0.0;
                      travel.push_back(current->children[i]);
                  }
                  current = current->children[0];
              }
          }
          else
              active.pop_back();

          // find distance with current node
          for (const auto& n : active)
              n->maxdistUB = std::max(n->maxdistUB, n->dist(current));

          // Pop
          travel.pop_back();
      }
    }
    void generate_id(Node* current){                //Generate IDs for each node from root as 0
      // assign current node
      current->ID = N++;
      // traverse children
      for (const auto& child : *current)
          generate_id(child);
    }


/************************* Public API ***********************************************/
public:
    CoverTree(Dataset& m_data){
      std::vector<pointType> pList = from_dataset(m_data);
      int truncate = -1;
      int end = pList.size();
      int begin = 0;

      //1. Compute the mean of entire data
      pointType mx = utils::ParallelAddList(pList).get_result()/pList.size();

      //2. Compute distance of every point from the mean || Variance
      pointType dists = utils::ParallelDistanceComputeList(pList, mx).get_result();

      //3. argort the distance to find approximate mediod
      std::vector<int> idx(end-begin);
      std::iota(std::begin(idx), std::end(idx), 0);
      auto comp_x = [&dists](int a, int b) { return dists[a] > dists[b]; };
      std::sort(std::begin(idx), std::end(idx), comp_x);
      std::cout<<"Max distance: " << dists[idx[0]] << std::endl;

      //4. Compute distance of every point from the mediod
      mx = pList[idx[0]];
      dists = utils::ParallelDistanceComputeList(pList, mx).get_result();

      int scale_val = std::ceil(std::log(dists.maxCoeff())/std::log(base));
      std::cout<<"Scale chosen: " << scale_val << std::endl;
      pointType temp = pList[idx[0]];
      min_scale = scale_val; //-1000;
      max_scale = scale_val; //-1000;
      truncate_level = truncate;
      N = 1;
      D = temp.rows();

      root = new CoverTree::Node;
      root->_p = temp;
      root->level = scale_val; //-1000;
      root->maxdistUB = powdict[scale_val+1024];
      int run_till = 50000 < end ? 50000 : end;
      for (int i = 1; i < run_till; ++i){
          //utils::progressbar(i, run_till);
          if(!insert(pList[idx[i]]))
              std::cout << "Insert failed!!!" << std::endl;
      }
      utils::progressbar(run_till, run_till);
      std::cout<<std::endl;

      std::cout << pList[0].rows() << ", " << pList.size() << std::endl;

      utils::parallel_for_progressbar(50000,end,[&](int i)->void{
      //for (int i = 50000; i < end; ++i){
          //utils::progressbar(i, end-50000);
          if(!insert(pList[idx[i]]))
              std::cout << "Insert failed!!!" << std::endl;
      });
    }

    /*** Destructor ***/
    /*** Destructor: deallocating all memories by a post order traversal ***/
    ~CoverTree(){}

    static std::vector<pointType> from_dataset(Dataset& m_data){
      const size_t items = m_data.m_chunk[0];
      const size_t dimensions = m_data.m_chunk[1];
    
      std::vector<pointType> pList(items);
      // pragma omp optimizations for parallel constructions
      for (size_t i=0;i<items;i++){
        const T* point = static_cast<T*>(m_data.m_p) + i * dimensions;
    
        pointType newPoint = pointType(dimensions);
        for(size_t d=0;d<dimensions;d++){
          newPoint[d] = point[d];
        }
        pList.push_back(newPoint);
      }
    
      return pList;
    }

    /*** Insert point p into the cover tree ***/
    bool insert(const pointType& p){
      bool result = false;
      id_valid = false;
      global_mut.lock_shared();
      if (root->dist(p) > root->covdist())
      {
          global_mut.unlock_shared();
          std::cout<<"Entered case 1: " << root->dist(p) << " " << root->covdist() << " " << root->level <<std::endl;
          std::cout<<"Requesting global lock!" <<std::endl;
          global_mut.lock();
          while (root->dist(p) > base * root->covdist()/(base-1))
          {
              CoverTree::Node* current = root;
              CoverTree::Node* parent = NULL;
              while (current->children.size()>0)
              {
                  parent = current;
                  current = current->children.back();
              }
              if (parent != NULL)
              {
                  parent->children.pop_back();
                  current->level = root->level + 1;
                  //current->maxdistUB = powdict[current->level + 1025];
                  current->children.push_back(root);
                  root = current;
              }
              else
              {
                  root->level += 1;
                  //root->maxdistUB = powdict[root->level + 1025];
              }
          }
          ++N;
          CoverTree::Node* temp = new CoverTree::Node;
          temp->_p = p;
          temp->level = root->level + 1;
          temp->parent = NULL;
          //temp->maxdistUB = powdict[temp->level+1025];
          temp->children.push_back(root);
          root->parent = temp;
          root = temp;
          max_scale = root->level;
          result = true;
          //std::cout << "Upward: " << minScale << " " << maxScale << std::endl;
          global_mut.unlock();
          global_mut.lock_shared();
      }
      else
      {
          //root->tempDist = root->dist(p);
          result = insert(root, p);
      }
      global_mut.unlock_shared();
      return result;

    }

    /*** Remove point p into the cover tree ***/
    bool remove(const pointType& p){
      bool ret_val = false;
      // First find the point
      std::pair<CoverTree::Node*, double> result(root, root->dist(p));
      NearestNeighbour(root, result.second, p, result);

      if (result.second<=0.0)
      {   // point found
          CoverTree::Node* node_p = result.first;
          CoverTree::Node* parent_p = node_p->parent;
          if (node_p == root)
          {
              std::cout << "Sorry can not delete root efficiently!" << std::endl;
          }
          else
          {
              // 1. Remove p from parent's list of child
              unsigned num_children = parent_p->children.size();
              for (unsigned i = 0; i < num_children; ++i)
              {
                  if (parent_p->children[i]==node_p)
                  {
                      parent_p->children[i] =  parent_p->children.back();
                      parent_p->children.pop_back();
                      break;
                  }

              }

              // 2. For each child q of p:
              for(CoverTree::Node* q : *node_p)
              {
                  CoverTree::insert(root, q);
              }

              //3. delete
              delete node_p;

              ret_val = true;
          }
      }
      return ret_val;
    }

    /*** Nearest Neighbour search ***/
    std::pair<CoverTree::Node*, double> NearestNeighbour(const pointType &p) const{
      std::pair<CoverTree::Node*, double> result(root, root->dist(p));
      NearestNeighbour(root, result.second, p, result);
      return result;
    }

    void NearestNeighbour(Node* current, double dist_current, const pointType &p, std::pair<CoverTree::Node*, double>& nn) const{
      // If the current node is the nearest neighbour
      if (dist_current < nn.second)
      {
          nn.first = current;
          nn.second = dist_current;
      }

      // Sort the children
      unsigned num_children = current->children.size();
      std::vector<int> idx(num_children);
      std::iota(std::begin(idx), std::end(idx), 0);
      std::vector<double> dists(num_children);
      //dist_count[current->level].fetch_add(num_children, std::memory_order_relaxed);
      for (unsigned i = 0; i < num_children; ++i)
          dists[i] = current->children[i]->dist(p);
      auto comp_x = [&dists](int a, int b) { return dists[a] < dists[b]; };
      std::sort(std::begin(idx), std::end(idx), comp_x);

      for (const auto& child_idx : idx)
      {
          Node* child = current->children[child_idx];
          double dist_child = dists[child_idx];
          if (child->maxdistUB > current->covdist()/(base-1))
              std::cout << "I am crazy because max upper bound is bigger than 2**i " << child->maxdistUB << " " << current->covdist()/(base-1) << std::endl;
          if (nn.second > dist_child - child->maxdistUB)
              NearestNeighbour(child, dist_child, p, nn);
      }
    }

    /*** k-Nearest Neighbour search ***/
    std::vector<std::pair<CoverTree::Node*, double>> kNearestNeighbours(const pointType &queryPt, unsigned numNbrs) const{
      // Do the worst initialization
      std::pair<CoverTree::Node*, double> dummy(new CoverTree::Node(), std::numeric_limits<double>::max());
      // List of k-nearest points till now
      std::vector<std::pair<CoverTree::Node*, double>> nnList(numNbrs, dummy);

      // Call with root
      double dist_root = root->dist(queryPt);
      kNearestNeighbours(root, dist_root, queryPt, nnList);

      return nnList;
    }

    void kNearestNeighbours(Node* current, double dist_current, const pointType& p, std::vector<std::pair<CoverTree::Node*, double>>& nnList) const{
      // TODO(manzilz): An efficient implementation ?
      // If the current node is eligible to get into the list
      if(dist_current < nnList.back().second)
      {
          auto comp_x = [](std::pair<CoverTree::Node*, double> a, std::pair<CoverTree::Node*, double> b) { return a.second < b.second; };
          std::pair<CoverTree::Node*, double> temp(current, dist_current);
          nnList.insert(
              std::upper_bound( nnList.begin(), nnList.end(), temp, comp_x ),
              temp
          );
          nnList.pop_back();
      }

      // Sort the children
      unsigned num_children = current->children.size();
      std::vector<int> idx(num_children);
      std::iota(std::begin(idx), std::end(idx), 0);
      std::vector<double> dists(num_children);
      for (unsigned i = 0; i < num_children; ++i)
          dists[i] = current->children[i]->dist(p);
      auto comp_x = [&dists](int a, int b) { return dists[a] < dists[b]; };
      std::sort(std::begin(idx), std::end(idx), comp_x);

      for (const auto& child_idx : idx)
      {
          Node* child = current->children[child_idx];
          double dist_child = dists[child_idx];
          if ( nnList.back().second > dist_child - child->maxdistUB)
              kNearestNeighbours(child, dist_child, p, nnList);
      }
    }

    /*** Range search ***/
    std::vector<std::pair<CoverTree::Node*, double>> rangeNeighbours(const pointType &queryPt, double range = 1.0) const{
      // List of nearest neighbors in the range
      std::vector<std::pair<CoverTree::Node*, double>> nnList;

      // Call with root
      double dist_root = root->dist(queryPt);
      rangeNeighbours(root, dist_root, queryPt, range, nnList);

      return nnList;
    }

    void rangeNeighbours(Node* current, double dist_current, const pointType &p, double range, std::vector<std::pair<CoverTree::Node*, double>>& nnList) const{
      // If the current node is eligible to get into the list
      if (dist_current < range)
      {
          std::pair<CoverTree::Node*, double> temp(current, dist_current);
          nnList.push_back(temp);
      }

      // Sort the children
      unsigned num_children = current->children.size();
      std::vector<int> idx(num_children);
      std::iota(std::begin(idx), std::end(idx), 0);
      std::vector<double> dists(num_children);
      for (unsigned i = 0; i < num_children; ++i)
          dists[i] = current->children[i]->dist(p);
      auto comp_x = [&dists](int a, int b) { return dists[a] < dists[b]; };
      std::sort(std::begin(idx), std::end(idx), comp_x);

      for (const auto& child_idx : idx)
      {
          Node* child = current->children[child_idx];
          double dist_child = dists[child_idx];
          if (range > dist_child - child->maxdistUB)
              rangeNeighbours(child, dist_child, p, range, nnList);
      }
    }


    /*** Unit Tests ***/
    bool check_covering() const{
      bool result = true;
      std::stack<CoverTree::Node*> travel;
      CoverTree::Node* curNode;

      // Initialize with root
      travel.push(root);

      // Pop, check and then push the children
      while (!travel.empty())
      {
          // Pop
          curNode = travel.top();
          travel.pop();

          // Check covering for the current -> children pair
          for (const auto& child : *curNode)
          {
              travel.push(child);
              if( curNode->dist(child) > curNode->covdist() )
                  result = false;
              //std::cout << *curNode << " -> " << *child << " @ " << curNode->dist(child) << " | " << curNode->covdist() << std::endl;
          }
      }
      return result;
    }

    /*** Return the level of root in the cover tree (== max_level) ***/
    int get_level(){return root->level;}
    void print_levels(){
      std::stack<CoverTree::Node*> travel;
      CoverTree::Node* curNode;

      // Initialize with root
      travel.push(root);
      // Pop, print and then push the children
      while (!travel.empty())
      {
          // Pop
          curNode = travel.top();
          travel.pop();

          // Count the level
          level_count[curNode->level]++;

          // Now push the children
          for (const auto& child : *curNode)
              travel.push(child);
      }

      for(auto const& qc : level_count){
          std::cout << "Number of nodes at level " << qc.first << " = " << qc.second << std::endl;
      }
    }

    /*** Return all points in the tree ***/
    std::vector<pointType> get_points(){
      std::vector<pointType> points;
      std::stack<CoverTree::Node*> travel;
      CoverTree::Node* current;

      // Initialize with root
      travel.push(root);

      N = 0;
      // Pop, print and then push the children
      while (!travel.empty())
      {
          // Pop
          current = travel.top();
          travel.pop();

          // Add to dataset
          points.push_back(current->_p);
          current->ID = N++;

          // Now push the children
          for (const auto& child : *current)
              travel.push(child);
      }

      return points;
    }

    /*** Count the points in the tree ***/
    unsigned count_points(){
      std::stack<CoverTree::Node*> travel;
      CoverTree::Node* current;

      // Initialize with root
      travel.push(root);

      unsigned result = 0;
      // Pop, print and then push the children
      while (!travel.empty())
      {
          // Pop
          current = travel.top();
          travel.pop();

          // Add to dataset
          ++result;

          // Now push the children
          for (const auto& child : *current)
              travel.push(child);
      }
      return result;
    }

    /*** Pretty print ***/
    //friend std::ostream& operator<<(std::ostream& os, const CoverTree& ct);
};


#endif //_COVER_TREE_H

